# Dưới đây là chương trình dùng đề loại bỏ các tập tin độc hại có thể thiết lập trên tất cả các hệ điều hành.
#!/usr/bin/python3
# Dòng này được gọi là shebang và nó chỉ ra đường dẫn đến trình thông dịch sẽ được sử dụng để thực thi tập lệnh. Trong trường hợp này, nó chỉ định rằng tập lệnh sẽ được chạy bằng Python 3.

import os
import sys
import json
import datetime
# Các dòng này nhập các mô-đun cần thiết: (để tương tác với hệ điều hành), (để tương tác với môi trường thời gian chạy Python), (để làm việc với dữ liệu JSON) và (để làm việc với ngày và giờ).ossysjsondatetime

# Tuyên bố có điều kiện:


if os.name == 'nt':
    LOG_FILE = "C:\\Program Files (x86)\\ossec-agent\\active-response\\active-responses.log"
else:
    LOG_FILE = "/var/ossec/logs/active-responses.log"
# Khối này đặt biến dựa trên hệ điều hành. Nếu hệ điều hành là Windows (), nó sẽ đặt đường dẫn cho phù hợp và đối với các hệ điều hành khác, nó sẽ đặt một đường dẫn khác.LOG_FILE'nt'

# Hằng:

ADD_COMMAND = 0
DELETE_COMMAND = 1
CONTINUE_COMMAND = 2
ABORT_COMMAND = 3

OS_SUCCESS = 0
OS_INVALID = -1
# Những dòng này xác định một số hằng số được sử dụng trong suốt tập lệnh.

# Định nghĩa lớp:

class message:
    def __init__(self):
        self.alert = ""
        self.command = 0
#Điều này định nghĩa một lớp đơn giản được đặt tên với hai thuộc tính: và .messagealertcommand

#Định nghĩa hàm:

#write_debug_file: Ghi thông báo gỡ lỗi vào tệp nhật ký.
def write_debug_file(ar_name, msg):
    with open(LOG_FILE, mode="a") as log_file:
        log_file.write(str(datetime.datetime.now().strftime('%Y/%m/%d %H:%M:%S')) + " " + ar_name + ": " + msg +"\n")
#setup_and_check_message: Đọc một thông điệp có định dạng JSON từ đầu vào tiêu chuẩn, kiểm tra tính hợp lệ của nó và trả về một đối tượng.message
def setup_and_check_message(argv):

    # get alert from stdin
    input_str = ""
    for line in sys.stdin:
        input_str = line
        break


    try:
        data = json.loads(input_str)
    except ValueError:
        write_debug_file(argv[0], 'Decoding JSON has failed, invalid input format')
        message.command = OS_INVALID
        return message

    message.alert = data

    command = data.get("command")

    if command == "add":
        message.command = ADD_COMMAND
    elif command == "delete":
        message.command = DELETE_COMMAND
    else:
        message.command = OS_INVALID
        write_debug_file(argv[0], 'Not valid command: ' + command)

    return message

# send_keys_and_check_message: Xây dựng và gửi tin nhắn có định dạng JSON bằng các khóa, đọc phản hồi và trả về mã kết quả.

def send_keys_and_check_message(argv, keys):

    # build and send message with keys
    keys_msg = json.dumps({"version": 1,"origin":{"name": argv[0],"module":"active-response"},"command":"check_keys","parameters":{"keys":keys}})

    write_debug_file(argv[0], keys_msg)

    print(keys_msg)
    sys.stdout.flush()

    # read the response of previous message
    input_str = ""
    while True:
        line = sys.stdin.readline()
        if line:
            input_str = line
            break

    # write_debug_file(argv[0], input_str)

    try:
        data = json.loads(input_str)
    except ValueError:
        write_debug_file(argv[0], 'Decoding JSON has failed, invalid input format')
        return message

    action = data.get("command")

    if "continue" == action:
        ret = CONTINUE_COMMAND
    elif "abort" == action:
        ret = ABORT_COMMAND
    else:
        ret = OS_INVALID
        write_debug_file(argv[0], "Invalid value of 'command'")

    return ret

# main: Chức năng chính điều phối việc thực thi tập lệnh.
def main(argv):

    write_debug_file(argv[0], "Started")

    # validate json and get command
    msg = setup_and_check_message(argv)

    if msg.command < 0:
        sys.exit(OS_INVALID)

    if msg.command == ADD_COMMAND:
        alert = msg.alert["parameters"]["alert"]
        keys = [alert["rule"]["id"]]
        action = send_keys_and_check_message(argv, keys)

        # if necessary, abort execution
        if action != CONTINUE_COMMAND:

            if action == ABORT_COMMAND:
                write_debug_file(argv[0], "Aborted")
                sys.exit(OS_SUCCESS)
            else:
                write_debug_file(argv[0], "Invalid command")
                sys.exit(OS_INVALID)

        try:
            os.remove(msg.alert["parameters"]["alert"]["data"]["virustotal"]["source"]["file"])
            write_debug_file(argv[0], json.dumps(msg.alert) + " Successfully removed threat")
        except OSError as error:
            write_debug_file(argv[0], json.dumps(msg.alert) + "Error removing threat")


    else:
        write_debug_file(argv[0], "Invalid command")

    write_debug_file(argv[0], "Ended")

    sys.exit(OS_SUCCESS)

# Thực thi tập lệnh:

if __name__ == "__main__":
    main(sys.argv)
# Khối này đảm bảo rằng hàm được thực thi khi tập lệnh được chạy, nhưng không phải khi nó được nhập dưới dạng mô-đun.main
# Tập lệnh dường như là một phần của một hệ thống lớn hơn để xử lý các phản hồi tích cực, có thể liên quan đến các cảnh báo bảo mật. Nó đọc một thông điệp định dạng JSON từ đầu vào tiêu chuẩn, xử lý tin nhắn dựa trên nội dung của nó và thực hiện một số hành động nhất định cho phù hợp. Các hành động bao gồm ghi vào nhật ký gỡ lỗi, gửi và nhận tin nhắn và thực hiện các thao tác cụ thể trên hệ thống.